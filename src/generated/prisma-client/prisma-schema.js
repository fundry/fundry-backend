module.exports = {
  // Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  typeDefs:
    // Please don't change this file manually but run `prisma generate` to update it.
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

    /* GraphQL */ `
      type AggregateProject {
        count: Int!
      }

      type AggregateUser {
        count: Int!
      }

      type BatchPayload {
        count: Long!
      }

      scalar Long

      type Mutation {
        createProject(data: ProjectCreateInput!): Project!
        updateProject(
          data: ProjectUpdateInput!
          where: ProjectWhereUniqueInput!
        ): Project
        updateManyProjects(
          data: ProjectUpdateManyMutationInput!
          where: ProjectWhereInput
        ): BatchPayload!
        upsertProject(
          where: ProjectWhereUniqueInput!
          create: ProjectCreateInput!
          update: ProjectUpdateInput!
        ): Project!
        deleteProject(where: ProjectWhereUniqueInput!): Project
        deleteManyProjects(where: ProjectWhereInput): BatchPayload!
        createUser(data: UserCreateInput!): User!
        updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
        updateManyUsers(
          data: UserUpdateManyMutationInput!
          where: UserWhereInput
        ): BatchPayload!
        upsertUser(
          where: UserWhereUniqueInput!
          create: UserCreateInput!
          update: UserUpdateInput!
        ): User!
        deleteUser(where: UserWhereUniqueInput!): User
        deleteManyUsers(where: UserWhereInput): BatchPayload!
      }

      enum MutationType {
        CREATED
        UPDATED
        DELETED
      }

      interface Node {
        id: ID!
      }

      type PageInfo {
        hasNextPage: Boolean!
        hasPreviousPage: Boolean!
        startCursor: String
        endCursor: String
      }

      type Project {
        id: ID!
        name: String!
        description: String
        images: [String!]!
        accepted: Boolean
        completed: Boolean
      }

      type ProjectConnection {
        pageInfo: PageInfo!
        edges: [ProjectEdge]!
        aggregate: AggregateProject!
      }

      input ProjectCreateimagesInput {
        set: [String!]
      }

      input ProjectCreateInput {
        id: ID
        name: String!
        description: String
        images: ProjectCreateimagesInput
        accepted: Boolean
        completed: Boolean
      }

      type ProjectEdge {
        node: Project!
        cursor: String!
      }

      enum ProjectOrderByInput {
        id_ASC
        id_DESC
        name_ASC
        name_DESC
        description_ASC
        description_DESC
        accepted_ASC
        accepted_DESC
        completed_ASC
        completed_DESC
      }

      type ProjectPreviousValues {
        id: ID!
        name: String!
        description: String
        images: [String!]!
        accepted: Boolean
        completed: Boolean
      }

      type ProjectSubscriptionPayload {
        mutation: MutationType!
        node: Project
        updatedFields: [String!]
        previousValues: ProjectPreviousValues
      }

      input ProjectSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: ProjectWhereInput
        AND: [ProjectSubscriptionWhereInput!]
        OR: [ProjectSubscriptionWhereInput!]
        NOT: [ProjectSubscriptionWhereInput!]
      }

      input ProjectUpdateimagesInput {
        set: [String!]
      }

      input ProjectUpdateInput {
        name: String
        description: String
        images: ProjectUpdateimagesInput
        accepted: Boolean
        completed: Boolean
      }

      input ProjectUpdateManyMutationInput {
        name: String
        description: String
        images: ProjectUpdateimagesInput
        accepted: Boolean
        completed: Boolean
      }

      input ProjectWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        description: String
        description_not: String
        description_in: [String!]
        description_not_in: [String!]
        description_lt: String
        description_lte: String
        description_gt: String
        description_gte: String
        description_contains: String
        description_not_contains: String
        description_starts_with: String
        description_not_starts_with: String
        description_ends_with: String
        description_not_ends_with: String
        accepted: Boolean
        accepted_not: Boolean
        completed: Boolean
        completed_not: Boolean
        AND: [ProjectWhereInput!]
        OR: [ProjectWhereInput!]
        NOT: [ProjectWhereInput!]
      }

      input ProjectWhereUniqueInput {
        id: ID
        name: String
      }

      type Query {
        project(where: ProjectWhereUniqueInput!): Project
        projects(
          where: ProjectWhereInput
          orderBy: ProjectOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Project]!
        projectsConnection(
          where: ProjectWhereInput
          orderBy: ProjectOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): ProjectConnection!
        user(where: UserWhereUniqueInput!): User
        users(
          where: UserWhereInput
          orderBy: UserOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [User]!
        usersConnection(
          where: UserWhereInput
          orderBy: UserOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): UserConnection!
        node(id: ID!): Node
      }

      type Subscription {
        project(
          where: ProjectSubscriptionWhereInput
        ): ProjectSubscriptionPayload
        user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
      }

      type User {
        id: ID!
        username: String!
        email: String!
        password: String!
        hasProject: Boolean
        image: Boolean
      }

      type UserConnection {
        pageInfo: PageInfo!
        edges: [UserEdge]!
        aggregate: AggregateUser!
      }

      input UserCreateInput {
        id: ID
        username: String!
        email: String!
        password: String!
        hasProject: Boolean
        image: Boolean
      }

      type UserEdge {
        node: User!
        cursor: String!
      }

      enum UserOrderByInput {
        id_ASC
        id_DESC
        username_ASC
        username_DESC
        email_ASC
        email_DESC
        password_ASC
        password_DESC
        hasProject_ASC
        hasProject_DESC
        image_ASC
        image_DESC
      }

      type UserPreviousValues {
        id: ID!
        username: String!
        email: String!
        password: String!
        hasProject: Boolean
        image: Boolean
      }

      type UserSubscriptionPayload {
        mutation: MutationType!
        node: User
        updatedFields: [String!]
        previousValues: UserPreviousValues
      }

      input UserSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: UserWhereInput
        AND: [UserSubscriptionWhereInput!]
        OR: [UserSubscriptionWhereInput!]
        NOT: [UserSubscriptionWhereInput!]
      }

      input UserUpdateInput {
        username: String
        email: String
        password: String
        hasProject: Boolean
        image: Boolean
      }

      input UserUpdateManyMutationInput {
        username: String
        email: String
        password: String
        hasProject: Boolean
        image: Boolean
      }

      input UserWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        username: String
        username_not: String
        username_in: [String!]
        username_not_in: [String!]
        username_lt: String
        username_lte: String
        username_gt: String
        username_gte: String
        username_contains: String
        username_not_contains: String
        username_starts_with: String
        username_not_starts_with: String
        username_ends_with: String
        username_not_ends_with: String
        email: String
        email_not: String
        email_in: [String!]
        email_not_in: [String!]
        email_lt: String
        email_lte: String
        email_gt: String
        email_gte: String
        email_contains: String
        email_not_contains: String
        email_starts_with: String
        email_not_starts_with: String
        email_ends_with: String
        email_not_ends_with: String
        password: String
        password_not: String
        password_in: [String!]
        password_not_in: [String!]
        password_lt: String
        password_lte: String
        password_gt: String
        password_gte: String
        password_contains: String
        password_not_contains: String
        password_starts_with: String
        password_not_starts_with: String
        password_ends_with: String
        password_not_ends_with: String
        hasProject: Boolean
        hasProject_not: Boolean
        image: Boolean
        image_not: Boolean
        AND: [UserWhereInput!]
        OR: [UserWhereInput!]
        NOT: [UserWhereInput!]
      }

      input UserWhereUniqueInput {
        id: ID
        username: String
        email: String
      }
    `
};
